This project is a simple excerise in implementing a 2D ising model in Rust. The model's parameters are all in the consts delcaration at the top of main.rs. Most of them are self explanatory, with those that are more obscure commented in the code. To change the overall size of the calculation, you can alter the number of full passes of the system: NSTEPS, or change the length of the array on one side: SIDE. Currently, I have it so that only square arrays are considered, but changing it to work with rectangular arrays is as simple as changing the NROWS = NSIDE to be some other usize number and the same for NCOLUMNS. Once compiled, simply running the binary will step the system through the provided number of iterations and plot the randomized initial state, and domain ridden final state assuming the temperature remains unchanged. The model depends on the temperature to evolve to the most likely ensemble. If T is greater than ~ 2.26 then the system prefers random oriented spins, if T is below that it prefers domains where the spins are all aligned, with the final state at very low temperature being all oriented the same direction.

Included is my julia implementation and of note, to use it obviously requires an installation of julia which can be found at julia-lang.org. I used julia 1.7.2, and the dependencies to run it need to be dowloaded via the package manager. The two used are BenchmarkTools, and GLMakie, which can be installed to julia in the REPL via pressing "]" and then typing "install BenchmarkTools, GLMakie". This will preompile the packages and can take some time depending on internet connection. Julia is JIT compiled so the first run of any program is generally slower than subsequent runs, so I was comparing the second and third and so on runs of the julia script with the runs of the Rust binary. I see julia take ~ 1.31 seconds to run the ising function and Rust takes ~ 2.2 seconds on my laptop. 